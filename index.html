<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>Modern Tooling</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "webspec"
          ,   shortName:    "modern-tooling"
          ,   editors:      [{ name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" }]
          ,   edDraftURI:   "http://w3c.github.io/modern-tooling/"
          ,   license:      "w3c-software"
          ,   repository:   "w3c/modern-tooling"
        };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document is meant to capture the state of the discussion about modernising the tooling
        that supports the making of W3C standards.
      </p>
      <p>
        Discussion is open to all. <a href="https://github.com/w3c/modern-tooling/">Pull requests</a>
        are welcome, and the discussion takes place in
        <a href="https://github.com/w3c/modern-tooling/issues">the issues</a>.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This is just informal work by an informal task force.
      </p>
    </section>

    <section>
      <h2>Problem Statement</h2>
      <p>
        W3C is a heavily tooled organisation. We did Web tools long before they became ubiquitous
        and our tooling has earned us two decades of praise — which is probably more than can be
        said for any other part of the organisation.
      </p>
      <p>
        But the Web has changed quite a fair bit since then. Today, tools abound. The Web is an
        application platform. Our users are happy using many third-party tools, and it is only
        natural that they will compare what they can find elsewhere to our offering, sometimes
        preferring other options.
      </p>
      <p>
        This causes problems:
      </p>
      <ul>
        <li>
          Our users move their work to third-party tools, where the data they produce in developing
          specifications may be lost or locked up. GitHub is a primary example here.
        </li>
        <li>
          The work that groups carry out is becoming increasingly scattered across services, such
          that it is hard to track and hard to join. Issue tracking for instance is all over the
          place.
        </li>
        <li>
          Our tools, even when they work well and remain the preferred option, are starting to look
          old in both styling and interaction style. It is hard for our users to maintain the
          impression that they are building the Web of tomorrow while using tools that are clearly
          from the 90s. Some of our more recent users even find them hard to understand. A good
          example is WBS or the mailing list archives.
        </li>
        <li>
          Accumulation is hard to manage and makes content hard to find. The W3C Web site and the
          majority of its services are exposed essentially as one single entity. After twenty years
          of accretion, that makes it hard to evolve as was made obvious in the recent discussion
          about upgrading it all to HTTPS. The heavily granular usage of ACLs makes it essentially
          impossible to index. Finding things on the W3C Web site typically involves knowing someone
          with the URL equivalent of an eidetic memory and asking them where to go. This issue is
          further compounded by user-hostile URL policies (datedspace). A good example here would
          be trying to find the next-generation pubrules service.
        </li>
      </ul>
      <p>
        We need an energetic rethink of the W3C’s tooling in order to stay relevant to our users.
        That is what this document endeavours to provide.
      </p>
      <section>
        <h2>The Plan</h2>
        <p>
          I expect to proceed as follows:
        </p>
        <ul>
          <li>
            Iterate over this document through
            <a href="https://github.com/w3c/modern-tooling/issues">issues</a> and
            <a href="https://github.com/w3c/modern-tooling/">pull requests</a>. All discussions are
            intended to be public.
          </li>
          <li>
            Go broad and assume it’s Christmas. I don't want to discourage input by having people
            think about constraints. It’s of course very likely that at the end we can’t get
            everything but that’s okay. We can easily prioritise later, but I don’t want to miss a
            good idea.
          </li>
          <li>
            Assume hackability. Even with the best and the pithiest involved in drafting this
            document it is a given that not everything that may be useful to some part of our
            community at some moment of the future will be thought of. We need to build to ensure
            that our users can refine and extend our work.
          </li>
          <li>
            Be particularly wary of the
            <a href="http://en.wikipedia.org/wiki/Gal%C3%A1pagos_syndrome">Galápagos syndrome</a>.
            There is every reason for W3C to have its specificities, even its quirks, but they need
            to be usable and manageable.
          </li>
          <li>
            Target mid-April for a first draft for internal W3C discussion; then present an overview
            to the AC at its early May meeting.
          </li>
          <li>
            Hopefully start implementing!
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h2>Tools &amp; Supporting Setup</h2>
      <p>
        This section is a categorised but unprioritised list of tools and services that W3C should
        deploy, as well as ideas on how to manage integration with third-party systems.
      </p>

      <section>
        <h2>Specification Development</h2>
        <p>
          The heart of what we produce is specifications, as a manifestation of consensus. These
          already have some tooling support but it can be both further and better integrated or
          documented.
        </p>
        <section>
          <h2>Automatic Publishing</h2>
          <p>
            Great progress has already been made thanks to the
            <a href="https://github.com/w3c/echidna">Echidna</a> system that can publish Working
            Drafts in an automated manner, as often as needed. This can effectively make TR
            documents and Editor’s Drafts indistinguishable.
          </p>
          <p>
            There are, however, still a number of exceptions to the documents that Echidna can
            publish, and a number of rough edges to the system itself and its documentation. It
            needs iterative improvements.
          </p>
          <p>
            It will also need to expose a stream of notifications (as described further below) for
            the documents it publishes.
          </p>
        </section>
        <section>
          <h2>De Facto GitHub</h2>
          <p>
            While the door needs to remain open for alternatives that our users may wish to avail
            themselves of, the expected default location for specifications (and any other
            W3C-related repository) should be GitHub, preferably under the
            <a href="https://github.com/w3c/">w3c</a> organisation. This has several implications.
          </p>
          <p>
            We need to <strong>document the proper usage of GitHub for such work</strong>. Some of
            our users who are not from the Web development community can at times struggle with the
            site or with common conventions. Team resources need to be dedicated to supporting 
            users of GitHub. A specific collaboration with GitHub may be considered if needed.
          </p>
          <p>
            Better even than documentation, which is often ignored, a <strong>tool that enables the
            Team to set up new repositories correctly</strong>, within conventions, and given a few
            specific options would be most useful.
          </p>
          <p>
            Groups regularly need to add new contributors to their repositories (or, on occasion, to
            remove them); which requires administrative powers. Sadly, the granularity of the ACL
            system there does not allow us to grant that power to non-Team participants, which in
            turn means that the Team needs to be called upon for everyday business. An interface to
            <strong>grant our users the ability to maintain a repository’s collaborators</strong>
            without involving the Team would be a time-saver.
          </p>
          <p>
            Naturally, GitHub could disappear, go bankrupt, be overtaken by an evil gang of mole
            rats, or simply fall behind. In such an event, we must have all the useful data at hand
            and, if possible, be able to exploit it elsewhere. Git certainly makes it easy to keep
            repository data — it only needs be cloned.
          </p>
          <p>
            But GitHub also has a lot of useful information that isn't in git: issues, discussions,
            etc. We also need to keep that around. For that, we need a <strong>GitHub backup
            tool</strong>. This would use git’s naturally distributed nature in conjunction with the
            ability to receive organisation-wide hooks (and use the API to grab everything) in order
            to store all the useful information. Ideally all work would happen under the
            <a href="https://github.com/w3c/">w3c</a> organisation but the tool ought to be flexible
            enough to account for there being work elsewhere.
          </p>
          <p>
            The hook system should also be used so as to produce a stream of notifications that can
            later be integrated into the dashboard.
          </p>
          <p>
            This also entail that both <code>dev.w3</code> and <code>dvcs.w3</code> should be phased
            out. No new repository should be created there and no new user granted access. Projects
            that are still active there should be moved (and redirected). Obviously the content
            already published that no one is touching will likely need to stay there, but it should
            essentially be a static, frozen archive of old work.
          </p>
        </section>
        <section>
          <h2>Specification Styles as a Community Project</h2>
          <p>
            We regularly hear complaints about the usability of our specification styles. Several
            projects were started to radically improve them, but petered out.
          </p>
          <p>
            At the same time, they cannot be changed radically overnight. Older specifications
            cannot be broken through style changes and we shouldn’t throw away the brand recognition
            that comes with the current style.
          </p>
          <p>
            The solution is to open up the management of these styles and drive the project through
            largely small, incremental updates to the stylesheets. A repository for the styles
            should be created and we should start accepting pull requests. At first a clean-up of
            the current code ought to be carried out. Then, regular releases ought to be made
            based on contributions.
          </p>
        </section>
        <section>
          <h2>Interactivity in Specifications</h2>
          <p>
            The Web is no longer a static medium that is essentially fluid print brought to the
            screen. Documents today can work with the user interactively. So far we have only very
            sporadically made use of these capabilities, when in fact they could greatly enhance the
            usage of our primary products.
          </p>
          <p>
            A common library should be developed to provide basic functionality across all
            specifications. This would include:
          </p>
          <ul>
            <li>Simple, streamlined bug reports from within the document.</li>
            <li>Easy linking to sections.</li>
            <li>Finding for each definition where it is used.</li>
            <li>Page-width and boilerplate visibility configurability.</li>
            <li>Integration with testing &amp; coverage results.</li>
            <li>Integration with existing issues lists.</li>
          </ul>
          <p>
            Like the styling project, this can easily start small and humble, and progressively grow
            into a highly useful system thanks to contributions.
          </p>
        </section>
        <section>
          <h2>Document Structure Beyond PubRules</h2>
          <p>
            The <a href="http://www.w3.org/2014/10/pubrules/">new PubRules</a> system 
            (<a href="https://github.com/w3c/specberus">Specberus</a>) is a welcome improvement in
            the toolbox. It still needs some UI fixes and should be moved to a location not intended
            to make it impossible to find but overall it should soon be able to replace the previous
            instantiation.
          </p>
          <p>
            We should, however, think beyond specification validation. As things stand today, it is
            extremely hard to get information out of our documents. Even when they are correct, they
            are all different. The RDF export is a very partial view and borderline unusable. The
            data that is extracted into W3C’s systems cannot be obtained, and is partial as well.
            Yet so much can be done with this information.
          </p>
          <p>
            We need to progressively refine the <em>components</em> that make up a specification and
            to rethink them using modern HTML constructs for document semantics and metadata. Step
            by step we need to start unifying these constructs across the board (having tools
            produce them and enforcing them through PubRules). Document structure and metadata needs
            to become eventually regular enough that TR can be used as an API.
          </p>
        </section>
        <section>
          <h2>Specification Production Tools</h2>
          <p>
            We have quality specification production tools and most specifications today make use of
            them. It is worth thinking about how, as a common ecosystem, they can be improved.
          </p>
          <p>
            One aspect in which they can be improved is to bring their source formats in line
            wherever it makes sense (and isn't disruptive). The end goal here is that contributors
            to specifications who move between groups should as much as possible find themselves
            able to switch between tools as easily as possible.
          </p>
          <p>
            This, naturally, should not be done at the cost of innovation in those tools, but it
            surely can be done for some of the common, well-understood aspects.
          </p>
        </section>
        <section>
          <h2>Cross-References Support</h2>
          <p>
            The Web platform is increasingly described by a large mesh of specifications that
            reference one another. Currently, this is done relatively poorly overall. There are
            several methods in use:
          </p>
          <ul>
            <li>
              Handwave about doing something the way another specification says to do it, with a
              reference to the whole document.
            </li>
            <li>
              Link to a definition in another specification, which can break (as has happened
              several times for people referencing HTML), and sometimes forget to include a formal
              reference.
            </li>
            <li>
              List imported definitions from other specifications, with links and references, and
              then use internal references to those. This is likely the best option available today,
              but it is cumbersome work.
            </li>
          </ul>
          <p>
            Ideally, all definitions from all specifications should be globally available. This
            would make it possible to simply reference them in a specification tool source format
            and get the correct link and reference handled. It would enable the generation of
            glossaries (we urgently need to phase out <a href="http://www.w3.org/2003/glossary/">the
            current one</a>). We could expose a searchable interface that would make it possible for
            people to find which specification defines what, and which make use of what concept or
            construct (something that would prove invaluable in coordination).
          </p>
        </section>
        <section>
          <h2>Live Examples</h2>
          <p>
            It is extremely common today to replace examples in documentation with live ones that
            can be edited and rendered using one of the many services that provide such
            functionality.
          </p>
          <p>
            While it is probably not acceptable to inject code from a third-party service into our
            specifications, there exist reusable components that would enable use to make the
            examples in our specifications hackable. This would have tremendous value for developers
            trying to learn and understand the technology.
          </p>
        </section>
        <section>
          <h2>Specref</h2>
          <p>
            <a href="http://www.specref.org/">Specref</a> is the database of
            bibliographical references that specifications rely upon. It has been through several
            iterations and is generally considered good, but it can be improved.
          </p>
          <p>
            It is currently managed by Tobie, it could be brought under W3C management.
          </p>
          <p>
            It could use a front-end for adding resources and a few other niceties to integrate
            it better with the W3C tool suite.
          </p>
        </section>
        <section>
          <h2>Specification Quality Checker (CI)</h2>
          <p>
            Some specification issues (that are not about the actual prose content) can sometimes
            exist for embarrassingly long periods of time before anyone notices. Sometimes they are
            noticed after a document is finalised. Or they are raised at the worst moment, all at
            once when the editor is busy doing something else.
          </p>
          <p>
            Developers use continuous integration to make sure that there is a constant pressure
            towards quality rather than a last-minute rush — so should editors. There have been
            experiments around this (using Travis’ integration with GitHub), they should be
            expanded and systematised.
          </p>
          <p>
            Ideally, an editor should be able to, at the click of a button, have the proper Travis
            integration (and dependencies) installed into the specification’s repository and
            deployed for immediate usage. This could even be made the default at repository creation
            if it is know that it will contain a specification.
          </p>
          <p>
            Several different tools can be called up on for quality checking; since they can be used
            on their own they are listed separately below and in the «Developer Tools» section.
          </p>
        </section>
        <section>
          <h2>WebIDL Checker</h2>
          <p>
            We have an existing WebIDL Checker. It needs to be integrated into the quality workflow
            (arguably into Specberus as well as into the linting options of specification tools),
            exist with guarantees of maintenance, documentation, and made easy to find.
          </p>
        </section>
        <section>
          <h2>References Checker</h2>
          <p>
            We have existing tools (that almost no one knows about) that can read a specification
            and validate that its references (at least to W3C or IETF documents) are up to date with
            the latest versions of those documents: the
            <a href="http://www.w3.org/2004/07/references-checker-ui">references checker</a> and the
            <a href="http://www.w3.org/2007/05/ietf-references-checker">IETF references checker</a>.
          </p>
          <p>
            While specification production tools, by building atop SpecRef, have largely removed the
            need for these, some specifications are produced by hand and some have local
            bibliographies. They should be part of automated checking.
          </p>
        </section>
        <section>
          <h2>Spell Checker</h2>
          <p>
            W3C actually exposes a <a href="http://www.w3.org/2002/01/spellchecker">Spell checker</a>
            tool (that can work with HTML). It is unclear that this could be integrated into
            automated checking (given the number of justifiable exceptions) but it could perhaps be
            made more prominent (or, if found not to be useful, retired).
          </p>
        </section>
        <section>
          <h2>Specification Diffs</h2>
          <p>
            W3C currently offers an <a href="http://www.w3.org/2007/10/htmldiff">HTML Diff</a>
            service which is sometimes used to see changes to documents.
          </p>
          <p>
            It is a common request to find out what has changed between two versions of a
            specification, in fact producing a diff seems slated to be part of the new errata
            management approach that the AB is investigating.
          </p>
          <p>
            This should be made automatic, and possibly specialised. Right now the HTML diff tool
            will produce as output a complete document, which can make the differences hard to find
            (e.g. a paragraph change in the whole HTML specification). It can also include a lot of
            spurious differences (for instance if a section was added at the beginning, all the
            section numbers come out as changes).
          </p>
          <p>
            This tool could be specialised for specifications in such a way that ignorable
            differences would be ignored. Also, an affordance could be exposed in specifications
            offering to see a diff between the version being looked at and any other version of this
            document.
          </p>
        </section>
        <section>
          <h2>WYSIWYG Specifications</h2>
          <p>
            Supporting WYSIWYG editing for specifications could help improve collaboration and
            contributions from people who might know HTML but are not necessarily versed in the
            specific formalism of a given specification tool.
          </p>
          <p>
            While such a tool would be interesting and valuable, it is a long and complex project
            to put together, and likely not a priority.
          </p>
        </section>
      </section>



      <section>
        <h2>Dashboard</h2>
        <p>
          
        </p>
      </section>
      <!--
        XXX
        - notifications
        - news
        - urgent announcements
        - AC rep user management
        - WBS as API+UI
        - the W3C Application (manage everything in there, using modules that talk to APIs)
        - widgets in the dashboard (how to load, allow third parties)
        - a service needs to provide unified feeds for everything so that they can be used by widgets
          - commits
          - issues
          - communications
        - widgets system in the dashboard (as separate software projects linked by npm)
          - W3CMemes widget as one of the test ones
          - list potential ones
          - integrated view for a group based on unified eventing
          - Netvibes like thing
          - widgets can go full screen into "apps"
          - preferences service
          - http://masonry.desandro.com/options.html might be enough, otherwise http://packery.metafizzy.co/
      -->
      
      <section>
        <h2>Groups &amp; Community</h2>
        <p>
          
        </p>
      </section>
      <!--
        XXX
        - chat
        - mailing list interface
        - mailing list subscription management
        - phone discussions (Twilio?)
        - online/group discussions (Discourse)
        - piratepad
        - collaborative todo
        - what to do with wikis? make sure there is a unified dashboard and notifications stream?
        - issue tracking: all needs to produce unified feeds
        - IRC logging
      -->
      
      <section>
        <h2>Developer Services</h2>
        <p>
          
        </p>
      </section>
      <!--
        - link checker
        - validator (CSS & HTML)
        - I18N checker (http://validator.w3.org/i18n-checker/)
        - A11Y checker
        - http://validator.w3.org/mobile/
      -->
      
      <section>
        <h2>Core Site</h2>
        <p>
          
        </p>
      </section>
      <!--
        XXX
        - move away from CVS, partitioning
        - Overview.html
        - datedspace
        - make it focus on public front end (plus legacy content), split all the rest out into 
          manageable units
      -->
      
      <section>
        <h2>Testing</h2>
        <p>
          
        </p>
      </section>
      <!--
        XXX
        - testing tooling (WPT)
        - coverage & links to specs
        - Critic
        - automatic runs against all browsers
        - running against SauceLabs
        - publishing results
      -->
       
      <section>
        <h2>Shipping</h2>
        <p>
          
        </p>
      </section>
      <!--
        XXX
        - need proper accessibility testing
        - needs to work on mobile
        - bots (and scribe.perl) need to work with this system
          - integrate with all the above (with notifications!)
          - can team people be recognised and given great privileges?
      -->

      <section>
        <h2>Core Services</h2>
        <p>
          These are services that can be reused by other parts of the ecosystem.
        </p>
        
        <section>
          <h2>Single Sign-On</h2>
          <p>
            Many tools and services will expose features that are user-dependent. It is not
            appropriate for those to implement their own user database duplicating W3C’s. It would
            also be a shame if they had to make use of third-party sign-on infrastructure (which
            was the case with Discourse).
          </p>
          <p>
            Which exact solution is selected here is of relatively little importance, but it does
            need to support typical modern Web application authentication workflows. GitHub’s
            <a href="https://developer.github.com/v3/oauth/">OAuth implementation</a> may provide a
            good example.
          </p>
          <p>
            It should also be possible to retrieve useful information about a user, such as their
            GitHub ID.
          </p>
        </section>
        
        <section>
          <h2>Search</h2>
          <p>
            The various tools to be developed may commonly require search functionality. Given the
            spread of W3C’s content, this can quickly become required. For instance, an Etherpad
            service might request indexing for its pads (using its own ACL knowledge), a chat
            logging service might index the logs, etc.
          </p>
          <p>
            One potential candidate, that can double as a JSON document store and therefore be
            usable for application data storage, is <a href="http://www.elasticsearch.org/">Elastic
            Search</a>.
          </p>
        </section>
      </section>
    </section>
    
    <section>
      <h2>Principles for Tool Integration</h2>
      <p>
        XXX
      </p>
    </section>
    <section>
      <h2>Implementation Plan</h2>
      <p>
        XXX
      </p>
    </section>
    <section>
      <h2>Resource Requirements</h2>
      <p>
        XXX
      </p>
    </section>
    <section>
      <h2>Acknowledgements</h2>
      <p>
        The following people have provided useful input into this document.
      </p>
      <ul>
        <li>Dave Singer</li>
        <li>Jeff Jaffe</li>
        <li>Philippe Le Hégaret</li>
      </ul>
    </section>
  </body>
</html>
